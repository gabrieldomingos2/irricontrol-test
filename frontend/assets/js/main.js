// --- Vari√°veis Globais de Estado (Anexadas a 'window') ---

window.modoEdicaoPivos = false;
window.coordenadaClicada = null;
window.marcadorPosicionamento = null;
window.backupPosicoesPivos = {};
window.modoLoSPivotAPivot = false; // Controla o novo modo de diagn√≥stico
window.losSourcePivot = null;      // Armazena o piv√¥ de origem selecionado {nome, latlng, altura}
window.losTargetPivot = null;    // Armazena o piv√¥ de destino selecionado {nome, latlng, altura}
window.modoBuscaLocalRepetidora = false; // Controla o modo de busca por locais de repetidora
window.pivoAlvoParaLocalRepetidora = null; // Armazena o piv√¥ alvo para a busca
window.ciclosGlobais = [];

// Novas/Modificadas vari√°veis globais para a funcionalidade de dist√¢ncia
window.antenaGlobal = null; // MODIFICADO: Garanta que seja window.antenaGlobal
window.distanciasPivosVisiveis = false; // Novo: controla a visibilidade das dist√¢ncias
window.lastPivosDataDrawn = []; // Novo: armazena os √∫ltimos dados de piv√¥s desenhados
window.currentProcessedKmzData = null; // Novo: armazena todos os dados do KMZ processado

// Vari√°veis globais que n√£o precisam ser window explicitamente se este script for o principal
let marcadorAntena = null;
let marcadoresPivos = [];
let circulosPivos = [];
let pivotsMap = {};
let repetidoras = [];
let contadorRepetidoras = 0;
let idsDisponiveis = [];
let legendasAtivas = true;
let marcadoresLegenda = [];
let marcadoresBombas = [];
let posicoesEditadas = {};
let overlaysVisiveis = [];
let templateSelecionado = "";
let linhasDiagnostico = [];
let marcadoresBloqueio = [];


// --- Inicializa√ß√£o ---

document.addEventListener("DOMContentLoaded", () => {
    console.log("DOM Carregado. Iniciando Aplica√ß√£o...");
    initMap();
    setupUIEventListeners();    // setupUIEventListeners deve ser chamado antes de setupMainActionListeners se ele adicionar elementos que main usa
    setupMainActionListeners();
    loadAndPopulateTemplates();
    reposicionarPaineisLaterais();
    lucide.createIcons();
    console.log("Aplica√ß√£o Pronta.");
});

// --- Configura√ß√£o dos Listeners Principais ---

function setupMainActionListeners() {
    document.getElementById('formulario').addEventListener('submit', handleFormSubmit);
    document.getElementById('simular-btn').addEventListener('click', handleSimulateClick);
    document.getElementById('resetar-btn').addEventListener('click', handleResetClick);
    document.getElementById('btn-diagnostico').addEventListener('click', handleDiagnosticoClick);
    document.getElementById('exportar-btn').addEventListener('click', handleExportClick);
    document.getElementById('confirmar-repetidora').addEventListener('click', handleConfirmRepetidoraClick);
    document.getElementById('btn-los-pivot-a-pivot').addEventListener('click', toggleLoSPivotAPivotMode);
    document.getElementById('btn-buscar-locais-repetidora').addEventListener('click', handleBuscarLocaisRepetidoraActivation);
    map.on("click", handleMapClick);

    // Novo listener para o bot√£o de dist√¢ncias
    const toggleDistanciasBtn = document.getElementById('toggle-distancias-pivos');
    if (toggleDistanciasBtn) {
        toggleDistanciasBtn.addEventListener('click', handleToggleDistanciasPivos);
    } else {
        console.error("Bot√£o 'toggle-distancias-pivos' n√£o encontrado no DOM.");
    }
}

// --- Handlers de A√ß√µes Principais ---

async function handleFormSubmit(e) {
    e.preventDefault();

    const fileInput = document.getElementById('arquivo');
    if (!fileInput.files || fileInput.files.length === 0) {
        mostrarMensagem("Por favor, selecione um arquivo KMZ.", "erro");
        return;
    }

    mostrarLoader(true);

    const formData = new FormData();
    formData.append("file", fileInput.files[0]);

    try {
        const data = await processKmz(formData); // Fun√ß√£o de api.js
        console.log("‚úÖ KMZ Processado:", data);
        window.currentProcessedKmzData = JSON.parse(JSON.stringify(data)); // Novo: armazena dados do KMZ

        if (data.erro) throw new Error(data.erro);

        handleResetClick(false); // Limpa o estado anterior antes de carregar novos dados

        // üóº Antena
        window.antenaGlobal = data.antena; // MODIFICADO: usar window.antenaGlobal
        if (window.antenaGlobal) { // MODIFICADO
            marcadorAntena = drawAntena(data.antena); // Fun√ß√£o de drawing.js
            addAntenaAoPainel(window.antenaGlobal); // Fun√ß√£o de drawing.js (ou ui.js)
        } else {
            console.warn("Dados da antena n√£o encontrados no KMZ processado.");
            mostrarMensagem("‚ö†Ô∏è Antena principal n√£o encontrada no KMZ.", "erro");
        }

        // üíß Bombas e C√≠rculos
        drawBombas(data.bombas || []); // Fun√ß√£o de drawing.js
        window.ciclosGlobais = data.ciclos || []; // Armazena os ciclos globalmente
        drawCirculos(window.ciclosGlobais); // Fun√ß√£o de drawing.js

        // üéØ Desenha os piv√¥s assumindo que todos est√£o inicialmente fora de cobertura
        const pivosParaDesenhar = data.pivos || [];
        const pivosComStatusInicial = pivosParaDesenhar.map(p => ({
            ...p,
            fora: true // Assume inicialmente fora de cobertura
        }));
        window.lastPivosDataDrawn = JSON.parse(JSON.stringify(pivosComStatusInicial)); // Novo: armazena dados dos piv√¥s
        drawPivos(pivosComStatusInicial); // Fun√ß√£o de drawing.js

        // üîç Ajusta o mapa para mostrar antena e piv√¥s
        if (window.antenaGlobal && pivosParaDesenhar.length > 0) { // MODIFICADO
            const boundsToFit = [
                [window.antenaGlobal.lat, window.antenaGlobal.lon] // MODIFICADO
            ];
            pivosParaDesenhar.forEach(p => boundsToFit.push([p.lat, p.lon]));
            map.fitBounds(boundsToFit, { padding: [50, 50] });
        } else if (window.antenaGlobal) { // MODIFICADO
            map.setView([window.antenaGlobal.lat, window.antenaGlobal.lon], 13); // MODIFICADO
        } else if (pivosParaDesenhar.length > 0) {
            const pivoBounds = pivosParaDesenhar.map(p => [p.lat, p.lon]);
            if (pivoBounds.length > 0) map.fitBounds(pivoBounds, { padding: [50, 50] });
        }

        atualizarPainelDados(); // Fun√ß√£o de ui.js
        mostrarMensagem("‚úÖ KMZ carregado com sucesso.", "sucesso"); // Fun√ß√£o de ui.js

        document.getElementById("simular-btn").classList.remove("hidden");
        document.getElementById("painel-dados").classList.remove("hidden");
        document.getElementById("painel-repetidoras").classList.remove("hidden");
        reposicionarPaineisLaterais();

    } catch (error) {
        console.error("‚ùå Erro no submit do formul√°rio:", error);
        mostrarMensagem(`‚ùå Erro ao carregar KMZ: ${error.message}`, "erro");
    } finally {
        mostrarLoader(false);
    }
}

async function handleSimulateClick() {
    if (!window.antenaGlobal) { // MODIFICADO
        mostrarMensagem("‚ö†Ô∏è Carregue um KMZ primeiro!", "erro");
        return;
    }

    mostrarLoader(true);

    try {
        templateSelecionado = document.getElementById('template-modelo').value;

        Object.entries(posicoesEditadas).forEach(([nome, novaPos]) => {
            if (pivotsMap[nome]) { pivotsMap[nome].setLatLng(novaPos); }
        });

        const pivos_atuais = Object.entries(pivotsMap).map(([nome, marcador]) => ({
            nome,
            lat: marcador.getLatLng().lat,
            lon: marcador.getLatLng().lng
            // O status 'fora' ser√° determinado pelo backend na simula√ß√£o
        }));

        const payload = { ...window.antenaGlobal, pivos_atuais, template: templateSelecionado }; // MODIFICADO
        const data = await simulateSignal(payload);
        console.log("‚úÖ Simula√ß√£o conclu√≠da:", data);

        if (data.erro) throw new Error(data.erro);

        overlaysVisiveis.forEach(overlay => {
            if (map.hasLayer(overlay)) map.removeLayer(overlay);
        });
        overlaysVisiveis = [];

        if (window.antenaGlobal.overlay && map.hasLayer(window.antenaGlobal.overlay)) { // MODIFICADO
            map.removeLayer(window.antenaGlobal.overlay); // MODIFICADO
        }

        window.antenaGlobal.overlay = drawImageOverlay(data.imagem_salva, data.bounds); // MODIFICADO
        window.antenaGlobal.bounds = data.bounds; // MODIFICADO

        window.lastPivosDataDrawn = JSON.parse(JSON.stringify(data.pivos)); // Novo: atualiza dados dos piv√¥s
        drawPivos(data.pivos, true); // 'true' para useEdited
        atualizarPainelDados();

        mostrarMensagem("üì° Estudo de sinal conclu√≠do.", "sucesso");
        document.getElementById("btn-diagnostico").classList.remove("hidden");

        const btnSimular = document.getElementById("simular-btn");
        btnSimular.disabled = true;
        btnSimular.classList.add("opacity-50", "cursor-not-allowed");

    } catch (error) {
        console.error("‚ùå Erro ao simular sinal:", error);
        mostrarMensagem(`‚ùå Falha na simula√ß√£o: ${error.message}`, "erro");
    } finally {
        mostrarLoader(false);
    }
}

function handleMapClick(e) {
    if (window.modoEdicaoPivos) return;
    if (window.modoLoSPivotAPivot) return; // Evitar colocar marcador de repetidora ao clicar em piv√¥ para LoS
    if (window.modoBuscaLocalRepetidora) return; // Evitar colocar marcador de repetidora ao clicar em piv√¥ para busca

    window.coordenadaClicada = e.latlng;
    window.removePositioningMarker();

    window.marcadorPosicionamento = L.marker(window.coordenadaClicada, {
        icon: posicionamentoIcon,
        interactive: false,
        opacity: 0.7,
        zIndexOffset: 1000
    }).addTo(map);

    document.getElementById("painel-repetidora").classList.remove("hidden");
}

async function handleConfirmRepetidoraClick() {
    if (!window.coordenadaClicada) {
        mostrarMensagem("‚ö†Ô∏è Clique no mapa primeiro para definir a posi√ß√£o!", "erro");
        return;
    }

    mostrarLoader(true);
    document.getElementById('painel-repetidora').classList.add('hidden');
    window.removePositioningMarker();

    const alturaAntena = parseFloat(document.getElementById("altura-antena-rep").value);
    const alturaReceiver = parseFloat(document.getElementById("altura-receiver-rep").value);
    templateSelecionado = document.getElementById('template-modelo').value;

    const id = idsDisponiveis.length > 0 ? idsDisponiveis.shift() : ++contadorRepetidoras;
    const nomeRep = `Repetidora ${id}`;

    const novaRepetidoraMarker = L.marker(window.coordenadaClicada, { icon: antenaIcon })
        .addTo(map);

    const labelWidth = (nomeRep.length * 7) + 10;
    const labelHeight = 20;

    const labelRepetidora = L.marker(window.coordenadaClicada, {
        icon: L.divIcon({
            className: 'label-pivo', // Reutiliza estilo
            html: nomeRep,
            iconSize: [labelWidth, labelHeight],
            iconAnchor: [labelWidth / 2, 45]
        }),
        labelType: 'repetidora' // Identifica como label de repetidora
    }).addTo(map);
    marcadoresLegenda.push(labelRepetidora);

    const repetidoraObj = {
        id,
        marker: novaRepetidoraMarker,
        overlay: null,
        label: labelRepetidora,
        altura: alturaAntena,
        altura_receiver: alturaReceiver,
        lat: window.coordenadaClicada.lat,
        lon: window.coordenadaClicada.lng
    };
    repetidoras.push(repetidoraObj);

    const pivosParaSimulacaoRepetidora = window.lastPivosDataDrawn.map(p => ({ // Usa lastPivosDataDrawn
        nome: p.nome,
        lat: p.lat, // Usa a posi√ß√£o atual de lastPivosDataDrawn
        lon: p.lon  // Usa a posi√ß√£o atual de lastPivosDataDrawn
    }));


    const payload = {
        lat: window.coordenadaClicada.lat,
        lon: window.coordenadaClicada.lng,
        altura: alturaAntena,
        altura_receiver: alturaReceiver,
        pivos_atuais: pivosParaSimulacaoRepetidora,
        template: templateSelecionado
    };

    try {
        const data = await simulateManual(payload);
        console.log("Simula√ß√£o Manual Conclu√≠da:", data);

        if (data.erro) throw new Error(data.erro);

        repetidoraObj.overlay = drawImageOverlay(data.imagem_salva, data.bounds, 1.0);
        addRepetidoraNoPainel(repetidoraObj); // Em drawing.js
        await reavaliarPivosViaAPI(); // Isso vai atualizar lastPivosDataDrawn e redesenhar

        mostrarMensagem(`üì° Repetidora ${id} adicionada e simulada.`, "sucesso");
        document.getElementById("painel-repetidoras").classList.remove("hidden");
        reposicionarPaineisLaterais();

    } catch (error) {
        console.error("Erro ao confirmar repetidora:", error);
        mostrarMensagem(`‚ùå Falha ao simular repetidora: ${error.message}`, "erro");
        map.removeLayer(novaRepetidoraMarker);
        map.removeLayer(labelRepetidora);
        marcadoresLegenda = marcadoresLegenda.filter(l => l !== labelRepetidora);
        repetidoras = repetidoras.filter(r => r.id !== id);
        if (!idsDisponiveis.includes(id)) idsDisponiveis.push(id);
        idsDisponiveis.sort((a, b) => a - b);
    } finally {
        mostrarLoader(false);
        window.coordenadaClicada = null;
        atualizarPainelDados();
    }
}

function handleBuscarLocaisRepetidoraActivation() {
    window.modoBuscaLocalRepetidora = !window.modoBuscaLocalRepetidora;
    const btn = document.getElementById('btn-buscar-locais-repetidora');
    btn.classList.toggle('glass-button-active', window.modoBuscaLocalRepetidora);

    if (window.modoBuscaLocalRepetidora) {
        mostrarMensagem("MODO BUSCA LOCAL REPETIDORA: Selecione um piv√¥ SEM SINAL (vermelho) como alvo.", "sucesso");
        window.pivoAlvoParaLocalRepetidora = null;
        if (window.marcadorPosicionamento) removePositioningMarker();
        document.getElementById("painel-repetidora").classList.add("hidden");

        if (window.modoLoSPivotAPivot) {
            toggleLoSPivotAPivotMode();
        }
        if (window.modoEdicaoPivos) {
            const editarPivosBtn = document.getElementById("editar-pivos");
            if (editarPivosBtn.classList.contains('glass-button-active')) {
                togglePivoEditing();
            }
        }
        map.getContainer().style.cursor = 'crosshair';
    } else {
        mostrarMensagem("Modo 'Buscar Locais para Repetidora' desativado.", "sucesso");
        map.getContainer().style.cursor = '';
        // Limpar locais candidatos se o modo for desativado
        if (window.candidateRepeaterSitesLayerGroup) {
            window.candidateRepeaterSitesLayerGroup.clearLayers();
        }
    }
}

async function handlePivotSelectionForRepeaterSite(pivoData, pivoMarker) {
    if (!window.modoBuscaLocalRepetidora) return;

    if (pivoMarker.options.fillColor === 'green') {
        mostrarMensagem("ALVO: Selecione um piv√¥ SEM SINAL (vermelho).", "erro");
        return;
    }

    window.pivoAlvoParaLocalRepetidora = {
        nome: pivoData.nome,
        lat: pivoMarker.getLatLng().lat,
        lon: pivoMarker.getLatLng().lng,
        altura_receiver: (window.antenaGlobal && window.antenaGlobal.altura_receiver) ? window.antenaGlobal.altura_receiver : 3 // MODIFICADO
    };

    mostrarMensagem(`Piv√¥ alvo ${window.pivoAlvoParaLocalRepetidora.nome} selecionado. Buscando locais...`, "info");
    mostrarLoader(true);
    map.getContainer().style.cursor = 'wait';

    const activeOverlaysForSearch = [];
    const antenaCheckbox = document.querySelector("#antena-item input[type='checkbox']");

    if (window.antenaGlobal?.overlay && map.hasLayer(window.antenaGlobal.overlay) && (!antenaCheckbox || antenaCheckbox.checked)) { // MODIFICADO
        const b = window.antenaGlobal.overlay.getBounds(); // MODIFICADO
        activeOverlaysForSearch.push({
            id: 'antena_principal',
            imagem: window.antenaGlobal.overlay._url.replace(BACKEND_URL + '/', ''), // MODIFICADO
            bounds: [b.getSouth(), b.getWest(), b.getNorth(), b.getEast()]
        });
    }

    repetidoras.forEach(rep => {
        const repCheckbox = document.querySelector(`#rep-item-${rep.id} input[type='checkbox']`);
        if (rep.overlay && map.hasLayer(rep.overlay) && (!repCheckbox || repCheckbox.checked)) {
            const b = rep.overlay.getBounds();
            activeOverlaysForSearch.push({
                id: `repetidora_${rep.id}`,
                imagem: rep.overlay._url.replace(BACKEND_URL + '/', ''),
                bounds: [b.getSouth(), b.getWest(), b.getNorth(), b.getEast()]
            });
        }
    });

    if (activeOverlaysForSearch.length === 0) {
        mostrarMensagem("Nenhuma √°rea de sinal (antena/repetidoras) ativa para basear a busca. Ative alguma cobertura.", "erro");
        mostrarLoader(false);
        map.getContainer().style.cursor = window.modoBuscaLocalRepetidora ? 'crosshair' : '';
        return;
    }

    try {
        const payload = {
            target_pivot_lat: window.pivoAlvoParaLocalRepetidora.lat,
            target_pivot_lon: window.pivoAlvoParaLocalRepetidora.lon,
            target_pivot_nome: window.pivoAlvoParaLocalRepetidora.nome,
            altura_antena_repetidora_proposta: parseFloat(document.getElementById("altura-antena-rep").value) || 5,
            altura_receiver_pivo: window.pivoAlvoParaLocalRepetidora.altura_receiver,
            active_overlays: activeOverlaysForSearch
        };

        const resultados = await findHighPointsForRepeater(payload);

        if (window.candidateRepeaterSitesLayerGroup) {
            window.candidateRepeaterSitesLayerGroup.clearLayers();
        } else {
            console.warn("candidateRepeaterSitesLayerGroup n√£o definido.");
        }

        if (resultados && resultados.candidate_sites && resultados.candidate_sites.length > 0) {
            drawCandidateRepeaterSites(resultados.candidate_sites, window.pivoAlvoParaLocalRepetidora);
            mostrarMensagem(`Encontrados ${resultados.candidate_sites.length} locais candidatos. Clique em um para simular.`, "sucesso");
        } else {
            mostrarMensagem("Nenhum local promissor encontrado nas √°reas de cobertura existentes.", "info");
        }

    } catch (error) {
        console.error("Erro ao buscar locais para repetidora:", error);
    } finally {
        mostrarLoader(false);
        map.getContainer().style.cursor = window.modoBuscaLocalRepetidora ? 'crosshair' : '';
    }
}

function handleResetClick(showMessage = true) {
    console.log("üîÑ Resetando aplica√ß√£o...");
    clearMapLayers();

    window.antenaGlobal = null; // MODIFICADO
    marcadorAntena = null;
    window.marcadorPosicionamento = null;
    marcadoresPivos = [];
    circulosPivos = [];
    pivotsMap = {};
    window.coordenadaClicada = null;
    repetidoras = [];
    contadorRepetidoras = 0;
    idsDisponiveis = [];
    legendasAtivas = true;
    marcadoresLegenda = [];
    marcadoresBombas = [];
    posicoesEditadas = {};
    window.backupPosicoesPivos = {};
    overlaysVisiveis = [];
    linhasDiagnostico = [];
    marcadoresBloqueio = [];
    window.ciclosGlobais = [];

    // Reset das novas vari√°veis globais
    window.distanciasPivosVisiveis = false;
    window.lastPivosDataDrawn = [];
    window.currentProcessedKmzData = null;

    // Reseta a UI do bot√£o de dist√¢ncias
    const btnDistancias = document.getElementById('toggle-distancias-pivos');
    if (btnDistancias) {
        btnDistancias.classList.remove('glass-button-active');
        btnDistancias.title = "Mostrar Dist√¢ncias dos Piv√¥s";
    }


    if (window.modoEdicaoPivos) {
        if (typeof togglePivoEditing === 'function' && document.getElementById("editar-pivos").classList.contains('glass-button-active')) {
            togglePivoEditing();
        }
        window.modoEdicaoPivos = false;
        const btnEditarReset = document.getElementById("editar-pivos");
        const btnEditarIconSpanReset = btnEditarReset.querySelector('.sidebar-icon');
        if (btnEditarIconSpanReset) {
             btnEditarIconSpanReset.style.webkitMaskImage = 'url(assets/images/pencil.svg)';
             btnEditarIconSpanReset.style.maskImage = 'url(assets/images/pencil.svg)';
        } else {
             btnEditarReset.innerHTML = `<i data-lucide="pencil" class="w-5 h-5"></i>`; // Fallback se o span n√£o existir
             if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        btnEditarReset.title = "Editar Piv√¥s";
        btnEditarReset.classList.remove('glass-button-active');
        document.getElementById("desfazer-edicao").classList.add("hidden");
    }

    if (window.modoLoSPivotAPivot) {
        if (typeof toggleLoSPivotAPivotMode === 'function' && document.getElementById('btn-los-pivot-a-pivot').classList.contains('glass-button-active')) {
            toggleLoSPivotAPivotMode();
        }
        window.modoLoSPivotAPivot = false;
        window.losSourcePivot = null;
        window.losTargetPivot = null;
        // document.getElementById('btn-los-pivot-a-pivot').classList.remove('glass-button-active'); // toggleLoSPivotAPivotMode j√° deve fazer isso
    }

    if (window.modoBuscaLocalRepetidora) {
        if (typeof handleBuscarLocaisRepetidoraActivation === 'function' && document.getElementById('btn-buscar-locais-repetidora').classList.contains('glass-button-active')) {
            handleBuscarLocaisRepetidoraActivation();
        }
        window.modoBuscaLocalRepetidora = false;
        window.pivoAlvoParaLocalRepetidora = null;
        // document.getElementById('btn-buscar-locais-repetidora').classList.remove('glass-button-active'); // handleBuscarLocaisRepetidoraActivation j√° deve fazer isso
    }

    if (map) {
        map.getContainer().style.cursor = '';
    }

    const btnSimular = document.getElementById("simular-btn");
    btnSimular.classList.add("hidden");
    btnSimular.disabled = false;
    btnSimular.classList.remove("opacity-50", "cursor-not-allowed");
    document.getElementById("btn-diagnostico").classList.add("hidden");

    const btnEditar = document.getElementById("editar-pivos");
    const btnEditarIconSpan = btnEditar.querySelector('.sidebar-icon');
    if (btnEditarIconSpan && !window.modoEdicaoPivos) {
        btnEditarIconSpan.style.webkitMaskImage = 'url(assets/images/pencil.svg)';
        btnEditarIconSpan.style.maskImage = 'url(assets/images/pencil.svg)';
        btnEditar.title = "Editar Piv√¥s";
        btnEditar.classList.remove('glass-button-active');
        document.getElementById("desfazer-edicao").classList.add("hidden");
    } else if (!window.modoEdicaoPivos && !btnEditarIconSpan) { // Fallback se o span n√£o existir
        btnEditar.innerHTML = `<i data-lucide="pencil" class="w-5 h-5"></i>`;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        btnEditar.title = "Editar Piv√¥s";
        btnEditar.classList.remove('glass-button-active');
        document.getElementById("desfazer-edicao").classList.add("hidden");
    }


    document.getElementById("lista-repetidoras").innerHTML = "";
    document.getElementById("painel-repetidora").classList.add("hidden");
    document.getElementById("painel-dados").classList.add("hidden");
    document.getElementById("painel-repetidoras").classList.add("hidden");

    const formElement = document.getElementById('formulario');
    if (formElement) {
        formElement.reset();
    }
    const nomeArquivoLabelElement = document.getElementById('nome-arquivo-label');
    if (nomeArquivoLabelElement) {
        nomeArquivoLabelElement.textContent = "Escolher Arquivo KMZ";
        nomeArquivoLabelElement.title = "Escolher Arquivo KMZ";
    }
    const rangeOpacidadeElement = document.getElementById("range-opacidade");
    if (rangeOpacidadeElement) {
        rangeOpacidadeElement.value = 1;
    }

    if (map) {
        map.setView([-15, -55], 5);
    }

    atualizarPainelDados();
    reposicionarPaineisLaterais();

    if (typeof toggleLegendas === 'function') {
        toggleLegendas(true); // Assume que true mostra as legendas
    }

    if (showMessage) mostrarMensagem("üîÑ Aplica√ß√£o resetada.", "sucesso");
}

async function handleDiagnosticoClick() {
    if (!window.antenaGlobal || Object.keys(pivotsMap).length === 0) { // MODIFICADO
        mostrarMensagem("‚ö†Ô∏è Rode o estudo de sinal primeiro!", "erro");
        return;
    }

    mostrarLoader(true);
    visadaLayerGroup.clearLayers();
    linhasDiagnostico = [];
    marcadoresBloqueio = [];

    const pivosVermelhos = Object.entries(pivotsMap).filter(([_, m]) => m.options.fillColor === 'red');

    if (pivosVermelhos.length === 0) {
        mostrarMensagem("‚úÖ Nenhum piv√¥ fora de cobertura para diagnosticar.", "sucesso");
        mostrarLoader(false);
        return;
    }

    mostrarMensagem(`üîç Analisando ${pivosVermelhos.length} piv√¥s...`, "sucesso");

    for (const [nome, marcador] of pivosVermelhos) {
        const payload = {
            pontos: [
                [window.antenaGlobal.lat, window.antenaGlobal.lon], // MODIFICADO
                [marcador.getLatLng().lat, marcador.getLatLng().lng]
            ],
            altura_antena: window.antenaGlobal.altura || 15, // MODIFICADO
            altura_receiver: window.antenaGlobal.altura_receiver || 3 // MODIFICADO
        };

        try {
            const data = await getElevationProfile(payload);
            drawDiagnostico(
                payload.pontos[0],
                payload.pontos[1],
                data.bloqueio,
                data.ponto_mais_alto,
                nome
            );
        } catch (error) {
            console.error(`Erro no diagn√≥stico do piv√¥ ${nome}:`, error);
            mostrarMensagem(`‚ö†Ô∏è Erro ao diagnosticar ${nome}.`, "erro");
        }
    }

    if (typeof lucide !== 'undefined') lucide.createIcons();
    mostrarLoader(false);
    mostrarMensagem("üîç Diagn√≥stico de visada conclu√≠do.", "sucesso");
    visadaVisivel = false; // Controla se a visada ser√° vis√≠vel inicialmente
    toggleVisada(); // Alterna para o estado desejado (pode precisar ajustar a l√≥gica de toggleVisada)
}

function handleExportClick() {
    if (!window.antenaGlobal?.overlay || !window.antenaGlobal.bounds) { // MODIFICADO
        mostrarMensagem("‚ö†Ô∏è Rode a simula√ß√£o principal primeiro para gerar a imagem!", "erro");
        return;
    }

    try {
        const latStr = formatCoordForFilename(window.antenaGlobal.lat); // MODIFICADO
        const lonStr = formatCoordForFilename(window.antenaGlobal.lon); // MODIFICADO
        templateSelecionado = document.getElementById('template-modelo').value;
        const template = templateSelecionado.toLowerCase();
        const nomeImagem = `sinal_${template}_${latStr}_${lonStr}.png`;
        const nomeBounds = `sinal_${template}_${latStr}_${lonStr}.json`;
        const url = getExportKmzUrl(nomeImagem, nomeBounds);
        window.open(url, '_blank');
        mostrarMensagem("üì¶ Preparando KMZ para download...", "sucesso");
    } catch (error) {
        console.error("Erro ao exportar KMZ:", error);
        mostrarMensagem(`‚ùå Erro ao exportar: ${error.message}`, "erro");
    }
}

async function reavaliarPivosViaAPI() {
    console.log("Reavaliando piv√¥s...");
    const pivosAtuaisParaReavaliacao = window.lastPivosDataDrawn.map(p => ({ // Usa lastPivosDataDrawn
        nome: p.nome,
        lat: p.lat,
        lon: p.lon
    }));

    if (pivosAtuaisParaReavaliacao.length === 0) {
        console.log("Nenhum piv√¥ para reavaliar (lastPivosDataDrawn est√° vazio).");
        // Se n√£o h√° piv√¥s em lastPivosDataDrawn, mas h√° no mapa (pivotsMap), poderia usar um fallback
        // Mas idealmente lastPivosDataDrawn deve estar sempre correto.
        return;
    }

    const overlays = [];
    const antenaCheckbox = document.querySelector("#antena-item input[type='checkbox']");
    if (window.antenaGlobal?.overlay && map.hasLayer(window.antenaGlobal.overlay) && (!antenaCheckbox || antenaCheckbox.checked)) { // MODIFICADO
        const b = window.antenaGlobal.overlay.getBounds(); // MODIFICADO
        overlays.push({
            imagem: window.antenaGlobal.overlay._url.replace(BACKEND_URL + '/', ''), // MODIFICADO
            bounds: [b.getSouth(), b.getWest(), b.getNorth(), b.getEast()]
        });
    }

    repetidoras.forEach(rep => {
        const repCheckbox = document.querySelector(`#rep-item-${rep.id} input[type='checkbox']`);
        if (rep.overlay && map.hasLayer(rep.overlay) && (!repCheckbox || repCheckbox.checked)) {
            const b = rep.overlay.getBounds();
            overlays.push({
                imagem: rep.overlay._url.replace(BACKEND_URL + '/', ''),
                bounds: [b.getSouth(), b.getWest(), b.getNorth(), b.getEast()]
            });
        }
    });


    if (overlays.length === 0 && pivosAtuaisParaReavaliacao.length > 0) { // Apenas se houver piv√¥s
        console.log("Nenhum overlay de sinal vis√≠vel, marcando todos os piv√¥s como fora de cobertura.");
        const pivosFora = pivosAtuaisParaReavaliacao.map(p => ({ ...p, fora: true }));
        window.lastPivosDataDrawn = JSON.parse(JSON.stringify(pivosFora)); // Atualiza com status 'fora'
        drawPivos(pivosFora, true); // useEdited = true
        atualizarPainelDados();
        return;
    }
     if (pivosAtuaisParaReavaliacao.length === 0) { // Se n√£o h√° piv√¥s, n√£o faz nada
        console.log("Nenhum piv√¥ para reavaliar.");
        return;
    }


    try {
        const data = await reevaluatePivots({ pivos: pivosAtuaisParaReavaliacao, overlays });
        if (data.pivos) {
            window.lastPivosDataDrawn = JSON.parse(JSON.stringify(data.pivos)); // Novo: atualiza dados dos piv√¥s
            drawPivos(data.pivos, true); // useEdited = true
            atualizarPainelDados();
            console.log("Piv√¥s reavaliados.");
        }
    } catch (error) {
        console.error("Erro ao reavaliar piv√¥s via API:", error);
        mostrarMensagem("‚ö†Ô∏è Erro ao atualizar cobertura.", "erro");
    }
}

function formatCoordForFilename(coord) {
    return coord.toFixed(6).replace('.', '_').replace('-', 'm');
}

function removePositioningMarker() {
    if (window.marcadorPosicionamento && map.hasLayer(window.marcadorPosicionamento)) {
        map.removeLayer(window.marcadorPosicionamento);
        window.marcadorPosicionamento = null;
    }
}
window.removePositioningMarker = removePositioningMarker;

// --- Fun√ß√µes de Edi√ß√£o de Piv√¥s ---

function enablePivoEditingMode() {
    window.modoEdicaoPivos = true;
    console.log("‚úèÔ∏è Ativando modo de edi√ß√£o com √≠cone de pino SVG.");
    window.backupPosicoesPivos = {}; // Armazena { nome: LatLng }

    const tamanho = 18;
    const altura = 26;

    // Usa window.lastPivosDataDrawn para obter os dados dos piv√¥s, incluindo nome e posi√ß√£o atual
    window.lastPivosDataDrawn.forEach(pivoInfo => {
        const nome = pivoInfo.nome;
        const currentLatLng = L.latLng(pivoInfo.lat, pivoInfo.lon); // Posi√ß√£o atual do piv√¥
        const marcadorOriginal = pivotsMap[nome]; // O circleMarker original

        window.backupPosicoesPivos[nome] = currentLatLng;

        const editMarkerIcon = L.divIcon({
            className: 'pivo-edit-handle-custom-pin',
            html: `
            <svg viewBox="0 0 28 40" width="${tamanho}" height="${altura}" xmlns="http://www.w3.org/2000/svg">
                <path d="M14 0 C7.486 0 2 5.486 2 12.014 C2 20.014 14 40 14 40 C14 40 26 20.014 26 12.014 C26 5.486 20.514 0 14 0 Z
                M14 18 C10.686 18 8 15.314 8 12 C8 8.686 10.686 6 14 6 C17.314 6 20 8.686 20 12 C20 15.314 17.314 18 14 18 Z"
                fill="#FF3333" stroke="#660000" stroke-width="1"/>
            </svg>`,
            iconSize: [tamanho, altura],
            iconAnchor: [tamanho / 2, altura]
        });

        const editMarker = L.marker(currentLatLng, {
            draggable: true,
            icon: editMarkerIcon
        }).addTo(map);

        if (marcadorOriginal) {
            marcadorOriginal.editMarker = editMarker; // Associa ao circleMarker
             map.removeLayer(marcadorOriginal); // Remove o circleMarker temporariamente
        } else {
            console.warn(`Marcador original para ${nome} n√£o encontrado em pivotsMap ao ativar edi√ß√£o.`);
            // Adiciona ao pivotsMap se n√£o existir, para consist√™ncia, embora n√£o deva acontecer
             pivotsMap[nome] = { editMarker: editMarker, getLatLng: () => editMarker.getLatLng(), options: { color: 'grey'} };
        }


        // A legenda √© gerenciada por drawPivos. Ao arrastar, precisamos atualizar a posi√ß√£o da legenda.
        // No entanto, drawPivos limpa e recria legendas.
        // Melhor abordagem: ao final do drag, atualizar posicoesEditadas e depois chamar drawPivos.
        // Ou, mover a legenda associada se ela for um L.Marker separado.
        // A legenda (L.divIcon) √© recriada por drawPivos.
        // Para o drag em tempo real, vamos esconder as legendas dos piv√¥s ou aceitar que n√£o se movem em tempo real.
        // Simples: `posicoesEditadas` √© atualizado no dragend.

        editMarker.on("drag", (e) => {
            // Poderia tentar mover a legenda aqui se ela fosse um objeto persistente e acess√≠vel
            // Mas drawPivos vai recri√°-la.
        });

        editMarker.on("dragend", (e) => {
            const novaPos = e.target.getLatLng();
            posicoesEditadas[nome] = { lat: novaPos.lat, lng: novaPos.lng }; // Atualiza posi√ß√µes editadas

            // Atualiza a posi√ß√£o em lastPivosDataDrawn para que drawPivos use a correta
            const pivoEmLastData = window.lastPivosDataDrawn.find(p => p.nome === nome);
            if (pivoEmLastData) {
                pivoEmLastData.lat = novaPos.lat;
                pivoEmLastData.lon = novaPos.lng;
            }
            // Redesenha os piv√¥s para atualizar a legenda e o circleMarker (que foi removido)
            // A fun√ß√£o drawPivos agora ser√° respons√°vel por desenhar o circleMarker na nova posi√ß√£o
            // e a legenda.
             if (typeof window.togglePivoDistances === 'function') { // Reutiliza para redesenhar
                window.togglePivoDistances(window.distanciasPivosVisiveis);
            }

            console.log(`üìç Piv√¥ ${nome} movido para:`, novaPos);
        });

        editMarker.on("contextmenu", (e) => {
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            if (confirm(`‚ùå Tem certeza que deseja remover o piv√¥ ${nome}?`)) {
                map.removeLayer(editMarker);

                // Remove dos dados principais
                window.lastPivosDataDrawn = window.lastPivosDataDrawn.filter(p => p.nome !== nome);
                window.currentProcessedKmzData.pivos = window.currentProcessedKmzData.pivos.filter(p => p.nome !== nome);


                delete pivotsMap[nome]; // Remove de pivotsMap (que armazena os circleMarkers)
                delete posicoesEditadas[nome];
                delete window.backupPosicoesPivos[nome];

                // Redesenha os piv√¥s restantes
                if (typeof window.togglePivoDistances === 'function') { // Reutiliza para redesenhar
                    window.togglePivoDistances(window.distanciasPivosVisiveis);
                }
                mostrarMensagem(`üóëÔ∏è Piv√¥ ${nome} removido.`, "sucesso");
                atualizarPainelDados();
            }
        });
        // N√£o removemos o circleMarker aqui, drawPivos vai lidar com isso.
        // Em vez disso, os circleMarkers e suas legendas s√£o limpos e recriados por drawPivos.
        // Mas os marcadores de edi√ß√£o (pinos) devem ser os √∫nicos vis√≠veis para os piv√¥s.
    });

    // Limpa os marcadores de piv√¥s (c√≠rculos e legendas) existentes, deixando apenas os pinos de edi√ß√£o
    marcadoresPivos.forEach(m => map.removeLayer(m));
    marcadoresPivos = [];
    marcadoresLegenda.filter(l => l.options.labelType === 'pivot').forEach(l => map.removeLayer(l));
    marcadoresLegenda = marcadoresLegenda.filter(l => l.options.labelType !== 'pivot');
    // Os circleMarkers em pivotsMap tamb√©m n√£o s√£o mais necess√°rios no modo de edi√ß√£o,
    // pois os pinos draggable os substituem.
    // Object.values(pivotsMap).forEach(m => { if(m && m.options && map.hasLayer(m)) map.removeLayer(m); });
    // pivotsMap ainda pode ser √∫til para referenciar os pinos de edi√ß√£o


    mostrarMensagem(
        "‚úèÔ∏è Modo de edi√ß√£o ativado. Arraste o pino vermelho ou clique com bot√£o direito para remover.",
        "sucesso"
    );
}


function disablePivoEditingMode() {
    window.modoEdicaoPivos = false;
    console.log("Desativando modo de edi√ß√£o e salvando.");

    // Remove os marcadores de edi√ß√£o (pinos vermelhos)
    Object.values(pivotsMap).forEach(marcadorWrapper => { // pivotsMap pode agora conter o editMarker
        if (marcadorWrapper && marcadorWrapper.editMarker && map.hasLayer(marcadorWrapper.editMarker)) {
            map.removeLayer(marcadorWrapper.editMarker);
            // delete marcadorWrapper.editMarker; // O wrapper √© o antigo circleMarker, que n√£o existe mais
        }
    });
    // Se pivotsMap foi modificado para armazenar os pinos, precisa de ajuste.
    // Assumindo que os pinos foram adicionados ao mapa, mas pivotsMap ainda refere-se aos circleMarkers (que foram removidos).
    // Vamos iterar pelos pinos de edi√ß√£o que foram armazenados nos marcadores originais
     window.lastPivosDataDrawn.forEach(pivoInfo => {
        const marcadorOriginal = pivotsMap[pivoInfo.nome]; // Este √© o wrapper do antigo circleMarker
        if (marcadorOriginal && marcadorOriginal.editMarker && map.hasLayer(marcadorOriginal.editMarker)) {
            map.removeLayer(marcadorOriginal.editMarker);
            delete marcadorOriginal.editMarker;
        }
    });


    // Os dados em window.lastPivosDataDrawn j√° devem ter as posi√ß√µes atualizadas pelo dragend.
    // O status 'fora' tamb√©m deve estar l√°.
    // Recalcular pivos_atuais com base em lastPivosDataDrawn para garantir consist√™ncia
    const pivos_atuais_para_desenhar = window.lastPivosDataDrawn.map(p => ({
        nome: p.nome,
        lat: p.lat,
        lon: p.lon,
        fora: p.fora, // Certifique-se que 'fora' est√° atualizado em lastPivosDataDrawn
        // Inclua outras propriedades do piv√¥ se necess√°rio para drawPivos
        ...(p.raio && { raio: p.raio }),
        ...(p.cor_original && { cor_original: p.cor_original })
    }));

    // Redesenha os piv√¥s (circleMarkers e legendas) com as posi√ß√µes salvas.
    // A fun√ß√£o drawPivos usar√° as posi√ß√µes de pivos_atuais_para_desenhar.
    // O segundo argumento 'true' (useEdited) em drawPivos pode n√£o ser estritamente necess√°rio
    // se pivos_atuais_para_desenhar j√° cont√©m as posi√ß√µes finais.
    drawPivos(pivos_atuais_para_desenhar, false); // false para useEdited, pois as posi√ß√µes j√° est√£o nos dados

    mostrarMensagem("üíæ Posi√ß√µes salvas. Rode a simula√ß√£o novamente se necess√°rio.", "sucesso");
    window.backupPosicoesPivos = {}; // Limpa o backup
    posicoesEditadas = {}; // Limpa as edi√ß√µes explicitas, pois foram incorporadas em lastPivosDataDrawn
}


function undoPivoEdits() {
    console.log("Desfazendo edi√ß√µes.");
    Object.entries(window.backupPosicoesPivos).forEach(([nome, posicaoOriginalLatLng]) => {
        const pivoEmLastData = window.lastPivosDataDrawn.find(p => p.nome === nome);
        if (pivoEmLastData) {
            pivoEmLastData.lat = posicaoOriginalLatLng.lat;
            pivoEmLastData.lon = posicaoOriginalLatLng.lng;
        }
        // Remove da lista de posi√ß√µes editadas explicitamente
        delete posicoesEditadas[nome];
    });

    // Redesenha os piv√¥s com as posi√ß√µes restauradas
    // disablePivoEditingMode j√° remove os pinos de edi√ß√£o e chama drawPivos
    // Mas queremos redesenhar enquanto ainda estamos no modo de edi√ß√£o (com os pinos)
    // Ou, se o "desfazer" tamb√©m sair do modo de edi√ß√£o:
    // disablePivoEditingMode(); // Isso chamaria drawPivos

    // Se o Desfazer for DENTRO do modo de edi√ß√£o:
    // Precisamos mover os pinos de edi√ß√£o para as posi√ß√µes originais
     Object.entries(window.backupPosicoesPivos).forEach(([nome, posicaoOriginalLatLng]) => {
        const marcadorOriginal = pivotsMap[nome]; // Wrapper do antigo circleMarker
        if (marcadorOriginal && marcadorOriginal.editMarker) {
            marcadorOriginal.editMarker.setLatLng(posicaoOriginalLatLng);
        }
    });
    // E ent√£o redesenhar os piv√¥s para atualizar suas legendas, se drawPivos n√£o for chamado por disablePivoEditingMode
    if (window.modoEdicaoPivos) { // Se ainda estiver no modo de edi√ß√£o
        // A l√≥gica de enablePivoEditingMode remove os circleMarkers.
        // Apenas movendo os pinos √© suficiente. As legendas s√£o problema.
        // Solu√ß√£o mais simples: Desfazer SAIR√Å do modo de edi√ß√£o.
        if (typeof togglePivoEditing === 'function') {
            togglePivoEditing(); // Sai do modo de edi√ß√£o, o que chamar√° disablePivoEditingMode -> drawPivos
        }
    }


    mostrarMensagem("‚Ü©Ô∏è Edi√ß√µes desfeitas. Modo de edi√ß√£o encerrado.", "sucesso");
}

function toggleLoSPivotAPivotMode() {
    window.modoLoSPivotAPivot = !window.modoLoSPivotAPivot;
    const btn = document.getElementById('btn-los-pivot-a-pivot');
    btn.classList.toggle('glass-button-active', window.modoLoSPivotAPivot);

    if (window.modoLoSPivotAPivot) {
        mostrarMensagem("MODO DIAGN√ìSTICO PIV√î A PIV√î: Selecione o piv√¥ de ORIGEM (com sinal/verde).", "sucesso");
        if (window.marcadorPosicionamento) removePositioningMarker();
        document.getElementById("painel-repetidora").classList.add("hidden");
        window.losSourcePivot = null;
        window.losTargetPivot = null;

        // Desativar outros modos
        if (window.modoEdicaoPivos) togglePivoEditing();
        if (window.modoBuscaLocalRepetidora) handleBuscarLocaisRepetidoraActivation();
        map.getContainer().style.cursor = 'help';


    } else {
        mostrarMensagem("Modo 'Diagn√≥stico Piv√¥ a Piv√¥' desativado.", "sucesso");
        window.losSourcePivot = null;
        window.losTargetPivot = null;
        map.getContainer().style.cursor = '';
    }
}

async function handleLoSPivotClick(pivoData, pivoMarker) {
    if (!window.modoLoSPivotAPivot) return;

    const isGoodSignalPivot = pivoMarker.options.fillColor === 'green';
    const pivotLatlng = pivoMarker.getLatLng();
    const defaultPivotHeight = window.antenaGlobal?.altura_receiver || 3; // MODIFICADO

    if (!window.losSourcePivot) {
        if (!isGoodSignalPivot) {
            mostrarMensagem("ORIGEM: Selecione um piv√¥ COM SINAL (verde).", "erro");
            return;
        }
        window.losSourcePivot = {
            nome: pivoData.nome,
            latlng: pivotLatlng,
            altura: defaultPivotHeight
        };
        mostrarMensagem(`ORIGEM: ${pivoData.nome} selecionado. Agora selecione o piv√¥ de DESTINO (sem sinal/vermelho).`, "sucesso");
    } else {
        if (pivoData.nome === window.losSourcePivot.nome) {
            mostrarMensagem(`ORIGEM: ${pivoData.nome} j√° √© a origem. Selecione o piv√¥ de DESTINO.`, "info");
            return;
        }

        if (isGoodSignalPivot) {
            const confirmaMudanca = confirm(`Voc√™ j√° selecionou ${window.losSourcePivot.nome} como origem. Deseja alterar a origem para ${pivoData.nome}?`);
            if (confirmaMudanca) {
                window.losSourcePivot = {
                    nome: pivoData.nome,
                    latlng: pivotLatlng,
                    altura: defaultPivotHeight
                };
                mostrarMensagem(`ORIGEM ALTERADA para: ${pivoData.nome}. Selecione o piv√¥ de DESTINO (sem sinal/vermelho).`, "sucesso");
            }
            return;
        }

        window.losTargetPivot = {
            nome: pivoData.nome,
            latlng: pivotLatlng,
            altura: defaultPivotHeight
        };

        mostrarLoader(true);
        try {
            const payload = {
                pontos: [
                    [window.losSourcePivot.latlng.lat, window.losSourcePivot.latlng.lng],
                    [window.losTargetPivot.latlng.lat, window.losTargetPivot.latlng.lng]
                ],
                altura_antena: window.losSourcePivot.altura,
                altura_receiver: window.losTargetPivot.altura
            };

            const resultadoApi = await getElevationProfile(payload);
            drawDiagnostico(
                payload.pontos[0],
                payload.pontos[1],
                resultadoApi.bloqueio,
                resultadoApi.ponto_mais_alto,
                `${window.losSourcePivot.nome} ‚Üí ${window.losTargetPivot.nome}`
            );
            mostrarMensagem(`Visada entre ${window.losSourcePivot.nome} e ${window.losTargetPivot.nome} analisada.`, "sucesso");

            window.losSourcePivot = null;
            window.losTargetPivot = null;
            if (window.modoLoSPivotAPivot) {
                mostrarMensagem("Selecione um novo piv√¥ de ORIGEM (com sinal/verde) ou desative o modo.", "info");
            }
        } catch (error) {
            console.error(`Erro no diagn√≥stico LoS Piv√¥ a Piv√¥:`, error);
            mostrarMensagem(`‚ö†Ô∏è Erro ao diagnosticar visada: ${error.message}`, "erro");
            window.losSourcePivot = null;
            window.losTargetPivot = null;
        } finally {
            mostrarLoader(false);
        }
    }
}


// --- NOVA FUN√á√ÉO PARA CONTROLAR VISIBILIDADE DAS DIST√ÇNCIAS ---
function handleToggleDistanciasPivos() {
    window.distanciasPivosVisiveis = !window.distanciasPivosVisiveis;
    const btn = document.getElementById('toggle-distancias-pivos');
    if (btn) {
        btn.classList.toggle('glass-button-active', window.distanciasPivosVisiveis);
        btn.title = window.distanciasPivosVisiveis ? "Esconder Dist√¢ncias dos Piv√¥s" : "Mostrar Dist√¢ncias dos Piv√¥s";
    }


    if (typeof window.togglePivoDistances === 'function') {
        window.togglePivoDistances(window.distanciasPivosVisiveis);
    } else {
        console.error("Fun√ß√£o togglePivoDistances n√£o encontrada em drawing.js. Certifique-se que drawing.js foi carregado.");
        // Como fallback, se a fun√ß√£o n√£o existir, tenta chamar drawPivos diretamente se houver dados.
        // Isso s√≥ funcionar√° se drawPivos em drawing.js j√° estiver modificado para ler window.distanciasPivosVisiveis.
        if (window.lastPivosDataDrawn && window.lastPivosDataDrawn.length > 0 && typeof drawPivos === 'function') {
            console.warn("Fallback: Chamando drawPivos diretamente para atualizar dist√¢ncias.");
            drawPivos(window.lastPivosDataDrawn, true); // true para useEdited
             mostrarMensagem(`Dist√¢ncias dos piv√¥s ${window.distanciasPivosVisiveis ? 'exibidas' : 'ocultas'} (via fallback).`, 'sucesso');
        } else if (typeof drawPivos !== 'function'){
             console.error("Fun√ß√£o drawPivos tamb√©m n√£o encontrada globalmente.");
        }
    }
}